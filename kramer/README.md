# Kramer
Automatic layout of structured hierarchical data
___
This is the core of the Kramer framework.  Simply, the hierarchical query is represented by a tree of [SchemaNodes](src/main/java/com/chiralbehaviors/layout/schema/SchemaNode.java).  There are only two kinds of nodes: [Relation](src/main/java/com/chiralbehaviors/layout/schema/Relation.java) and [Primitive](src/main/java/com/chiralbehaviors/layout/schema/Primitive.java).  The algorithm is largely inspired by the paper [Automatic Layout of Structured Hierarchical Reports](http://people.csail.mit.edu/ebakke/research/reportlayout_infovis2013.pdf).  I say "inspired" because I really couldn't figure anything out wrt their actual algorithm from the paper other than the broad outlines of the idea.  The data structures sections hints at things, but it was a difficult time teasing that crap out through iterative coding.  I believe I have a pretty good idea of what they most likely came up with, but given that I really suck at UI stuff, I can only guess not having any other concrete implementation to compare mine against.  So it's been a pretty nice learning experience in a domain I usually avoid.  Always nice to have that.

The current state of the layout algorithm performs the reactive layout, hybridizing between _Outline_ and _Nested Table_ layouts.  The multicolumn extension is now working and is a huge win.  The number of columns is determined dynamically, and there's some filling that is not occurring on nested tables in multiple columns.  But that will eventually show up.

The UI implementation is largely able to be seperated out now, but I haven't even tried to do that refactoring.  There's a lot of shared context there that would be weird to put into another place, and the Layout isn't the schema.  I'm ignoring it mostly because I'm currently happy with JavaFX, and if you need this in Swing or some other god forsaken Java UI framework, then you're on your own.  Frankly, I don't think the translation is all that difficult.  After I get this all working to my current goal, I plan to port this to JavaScript and expose it in React and Angular (too).  If you look at the code, it's actually pretty straight forward stuff once you take out the particulars of JavaFX (vs, say, React).

As I said, I'm not a UI guy and damn if this hasn't a difficult trail for me.  An interesting one to be sure, but a difficult one.  I started long ago with real nested tables.  And that looked like shit, simply because of the repeated headers.  Trying to take the headers off the table and keep that aligned with the outer, top level headers was - at the time - beyond my ken.

In any event, the current iteration uses nested lists and the obvious column spanning strategy.  I use the constraints on the column to keep the individually nested "cells" in sync from a column width perspective.  One infuriating thing about layout is scroll bars.  They appear by magic, and you're not sure how your layout is going to be resized.  I could do all this statically, but I found it much easier and actually a lot more visually pleasing to let the JavaFX framework do the remaining constraints that make everything look nice.

The multi column addition was incredibly interesting.  As I've repeatedly mentioned, I'm not a UI person and damn if this didn't turn out to be an interesting problem.  It was a bit of dynamic programming that I had to largely cobble together as I coudn't find any examples that did what I needed.  In the end it seems like the algo was pretty simple, but I suppose the heuristics coud use some work.  Taking into account variable length content in the distribution of the vertical whitespace during the columnization process.  Still.  Boatloads of neurons stressed to come up with it.

One thing that took a long time was the whole [Layout](src/main/java/com/chiralbehaviors/layout/Layout.java) implementation.  It wasn't obvious how to get this information in the way I needed it and that was hard won.  I expect getting this in JavaScript is likely trivial - or at least not as sucky.  But who knows.  In any event, that's a nice little bit of kit that provides the layout parameters and measurements we need for the layout algorithm.

The top level control is the aptly named [AutoLayoutView](src/main/java/com/chiralbehaviors/layout/AutoLayoutView.java).  You'll note that the system trucks in the [Jackson TreeModel (JsonNode) framework](http://wiki.fasterxml.com/JacksonTreeModel).  This is because all I really care about is JSON or something that Jackson can convert to JSON, which is a lot of things (e.g. YAML).  It's a super convienent framework that takes the place of using Maps, Lists and god only knows how much blood, sweat and sanity points.  So, that's a dependency I could have tried to elide, but again - why?

In any event, you create the view by specifying the top level _Relation_ for the view and an optional _LayoutModel_.  The _LayoutModel_ is my way of providing the developer the ability to customize the lists and such.  You can see an example of this in the [Toy Application](../toy-app/README.md), single page application module.  The model couples the logic of setting up menus and other behavior such as double click, which the _Toy Application_ uses for navigation.

I tried to follow the JavaFX double bindings pattern, but I think it's silly.  I'm a big believer in Redux and such and so that's the way the control was designed to be used (however poorly I may have implemented it, of course).

When the control is resized to a different width, it will automatically adjust the layout and reconstruct the control.  Obviously, this can get quite expensive with a lot of nested data.  The JavaFX framework provides some relief here in that JavaFX controls provide some level of caching and optimization.  It's actually not the best at caching, but at least it tries.  The incremental support for at least my test data shows that it isn't too bad.  Basically, my test Star Wars allFilms query is a non trivial dataset and it works pretty fast and doesn't consume too many nodes initially.  However, as you scroll through the dataset, things start piling up.  I've done extensive investigations along the way with the [ScenicView](http://fxexperience.com/scenic-view/) tool.  Right now it's about 4K nodes, and it used to be something like 15K when I was being an idiot.  JavaFX can actually handle quite a huge number of nodes and so it's not been a problem yet.  I think the current model is reasonably optimial, but I could provide some savings by emulating the boxes and other layouts.  But again, why?  It would consume my life and frankly I have a lot of other things to work on at the moment.  Hopefully I'll get to better shedding of nodes as I work with things more.

Currently, the Primitives are all treated as Strings.  This is obviously limiting, but since every primitive can be translated to strings, it's an easy generalization that allows me to focus on the extremely difficult (for me at least) process of layout of this shit.  It's tough enough with teh wacky TextArea model that JavaFX has (I mean, who in their right mind makes the essential insets of the god damned TextArea fricking *PRIVATE*?).  Now that I largely have worked this out, I'll try to implement other controls for the primitives so far more richer interaction can be availble through the Kramer framework.
